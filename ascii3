package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea"
)

const (
	// ANSI colors
	Reset  = "\033[0m"
	Green  = "\033[32m"
	Gray   = "\033[90m"
	Yellow = "\033[33m"
	Blue   = "\033[34m"
)

type execMsg struct {
	out string
	err string
	cmd string
	t   time.Time
}

type model struct {
	// layout
	width, height int

	// left/right panels state
	leftDir    string
	rightDir   string
	leftFiles  []os.DirEntry
	rightFiles []os.DirEntry

	cursorLeft  int
	cursorRight int
	offsetLeft  int
	offsetRight int
	activeLeft  bool // which panel is active when focus == "panels"

	// focus: "panels" or "term"
	focus string

	// terminal state
	termInput   string
	termHistory []string

	// running command
	runningCmd bool
}

func main() {
	// start dirs: left = cwd, right = home
	cwd, _ := os.Getwd()
	home, _ := os.UserHomeDir()

	m := initialModel(cwd, home)
	p := tea.NewProgram(m, tea.WithAltScreen())
	if err := p.Start(); err != nil {
		fmt.Println("Ошибка запуска:", err)
		os.Exit(1)
	}
}

func initialModel(leftStart, rightStart string) model {
	m := model{
		leftDir:    leftStart,
		rightDir:   rightStart,
		activeLeft: true,
		focus:      "panels",
	}
	m.reloadDirs()
	return m
}

func (m *model) reloadDirs() {
	m.leftFiles = readDirSafe(m.leftDir)
	m.rightFiles = readDirSafe(m.rightDir)
	// clamp cursors/offsets
	if m.cursorLeft >= len(m.leftFiles) {
		m.cursorLeft = max(0, len(m.leftFiles)-1)
	}
	if m.cursorRight >= len(m.rightFiles) {
		m.cursorRight = max(0, len(m.rightFiles)-1)
	}
	if m.offsetLeft > m.cursorLeft {
		m.offsetLeft = m.cursorLeft
	}
	if m.offsetRight > m.cursorRight {
		m.offsetRight = m.cursorRight
	}
}

func readDirSafe(p string) []os.DirEntry {
	ents, err := os.ReadDir(p)
	if err != nil {
		return []os.DirEntry{}
	}
	return ents
}

func (m model) Init() tea.Cmd { return nil }

// runShellCmd executes a shell command asynchronously and returns a tea.Cmd that will send execMsg
func runShellCmd(cmdLine string) tea.Cmd {
	return func() tea.Msg {
		// Use sh -c on unix, cmd /C on windows
		var cmd *exec.Cmd
		if runtime.GOOS == "windows" {
			cmd = exec.Command("cmd", "/C", cmdLine)
		} else {
			cmd = exec.Command("/bin/sh", "-c", cmdLine)
		}
		var outb, errb bytes.Buffer
		cmd.Stdout = &outb
		cmd.Stderr = &errb
		_ = cmd.Run()
		return execMsg{out: outb.String(), err: errb.String(), cmd: cmdLine, t: time.Now()}
	}
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch tm := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = tm.Width
		m.height = tm.Height
		return m, nil

	case execMsg:
		// got command result
		line := fmt.Sprintf("%s$ %s%s", Yellow, tm.cmd, Reset)
		m.termHistory = append(m.termHistory, line)
		if tm.out != "" {
			for _, l := range strings.Split(strings.TrimSuffix(tm.out, "\n"), "\n") {
				m.termHistory = append(m.termHistory, l)
			}
		}
		if tm.err != "" {
			for _, l := range strings.Split(strings.TrimSuffix(tm.err, "\n"), "\n") {
				m.termHistory = append(m.termHistory, fmt.Sprintf("%sERR:%s %s", Yellow, Reset, l))
			}
		}
		m.runningCmd = false
		return m, nil

	case tea.KeyMsg:
		k := tm.String()

		// Global keys
		switch k {
		case "ctrl+c", "q":
			return m, tea.Quit
		case "tab":
			// toggle focus between panels and terminal
			if m.focus == "panels" {
				m.focus = "term"
			} else {
				m.focus = "panels"
			}
			return m, nil
		}

		if m.focus == "panels" {
			// panel navigation keys
			switch k {
			case "left":
				m.activeLeft = true
			case "right":
				m.activeLeft = false
			case "up":
				if m.activeLeft {
					if m.cursorLeft > 0 {
						m.cursorLeft--
						if m.cursorLeft < m.offsetLeft {
							m.offsetLeft--
						}
					}
				} else {
					if m.cursorRight > 0 {
						m.cursorRight--
						if m.cursorRight < m.offsetRight {
							m.offsetRight--
						}
					}
				}
			case "down":
				if m.activeLeft {
					if m.cursorLeft < len(m.leftFiles)-1 {
						m.cursorLeft++
						visible := panelVisibleItems(m.height)
						if m.cursorLeft >= m.offsetLeft+visible {
							m.offsetLeft++
						}
					}
				} else {
					if m.cursorRight < len(m.rightFiles)-1 {
						m.cursorRight++
						visible := panelVisibleItems(m.height)
						if m.cursorRight >= m.offsetRight+visible {
							m.offsetRight++
						}
					}
				}
			case "enter":
				// enter into directory if possible
				if m.activeLeft {
					if idxInRange(m.cursorLeft, m.leftFiles) {
						ent := m.leftFiles[m.cursorLeft]
						if ent.IsDir() {
							m.leftDir = filepath.Join(m.leftDir, ent.Name())
							m.cursorLeft, m.offsetLeft = 0, 0
							m.reloadDirs()
						}
					}
				} else {
					if idxInRange(m.cursorRight, m.rightFiles) {
						ent := m.rightFiles[m.cursorRight]
						if ent.IsDir() {
							m.rightDir = filepath.Join(m.rightDir, ent.Name())
							m.cursorRight, m.offsetRight = 0, 0
							m.reloadDirs()
						}
					}
				}
			case "backspace":
				// go to parent
				if m.activeLeft {
					parent := filepath.Dir(m.leftDir)
					if parent != m.leftDir {
						m.leftDir = parent
						m.cursorLeft, m.offsetLeft = 0, 0
						m.reloadDirs()
					}
				} else {
					parent := filepath.Dir(m.rightDir)
					if parent != m.rightDir {
						m.rightDir = parent
						m.cursorRight, m.offsetRight = 0, 0
						m.reloadDirs()
					}
				}
			}
			return m, nil
		}

		// focus == "term"
		// typing into terminal
		switch k {
		case "enter":
			trim := strings.TrimSpace(m.termInput)
			if trim != "" {
				// append "running" marker and run command async
				m.termHistory = append(m.termHistory, fmt.Sprintf("%s$ %s%s", Yellow, trim, Reset))
				m.runningCmd = true
				inp := trim
				m.termInput = ""
				return m, runShellCmd(inp)
			}
			m.termInput = ""
			return m, nil
		case "backspace":
			if len(m.termInput) > 0 {
				m.termInput = m.termInput[:len(m.termInput)-1]
			}
			return m, nil
		default:
			// add single characters
			// ignore control names like "up", "down" etc.
			if len(k) == 1 {
				m.termInput += k
			}
			return m, nil
		}
	}
	return m, nil
}

func idxInRange(i int, arr []os.DirEntry) bool {
	return i >= 0 && i < len(arr)
}

func panelVisibleItems(termH int) int {
	// compute visible rows in panel area (top area)
	// we'll leave 3 rows extra for spacing: top/bottom borders and terminal gap
	termH2 := termH
	termBottom := max(6, termH/4) // reserved for terminal
	topH := termH2 - termBottom - 3
	if topH < 3 {
		topH = 3
	}
	// visible = topH - 3 (for title + borders)
	return topH - 3
}

func renderPanelBlock(dir string, files []os.DirEntry, cursor, offset, width, height int, active bool) string {
	border := "-"
	color := Gray
	if active {
		border = "="
		color = Green
	}
	// header: +=====+ with title
	title := filepath.Base(dir)
	if title == "." || title == "" {
		title = dir
	}
	titleText := " " + title + " "
	// construct top border with title
	innerW := max(1, width-2)
	topBorder := "+" + strings.Repeat(border, innerW) + "+"

	// Build lines
	var lines []string
	lines = append(lines, colorize(topBorder, color))

	// title line (we'll just print title left)
	titleLine := "|"
	titleContent := titleText
	if len(stripANSI(titleContent)) > innerW {
		titleContent = titleContent[:innerW]
	}
	titleLine += padRight(titleContent, innerW) + "|"
	lines = append(lines, colorize(titleLine, color))

	visible := panelVisibleItems(height)
	// slice files based on offset and visible
	start := offset
	if start < 0 {
		start = 0
	}
	end := start + visible
	if end > len(files) {
		end = len(files)
	}
	for i := start; i < end; i++ {
		ent := files[i]
		name := ent.Name()
		if ent.IsDir() {
			name = name + "/"
		}
		prefix := "  "
		if i == cursor {
			prefix = Yellow + "> " + Reset
		} else {
			prefix = "  "
		}
		lineContent := prefix + name
		if len(stripANSI(lineContent)) > innerW {
			lineContent = truncateDisplay(lineContent, innerW)
		}
		line := "|" + padRight(lineContent, innerW) + "|"
		lines = append(lines, colorize(line, color))
	}
	// fill empty rows
	filled := end - start
	for i := 0; i < visible-filled; i++ {
		empty := "|" + padRight("", innerW) + "|"
		lines = append(lines, colorize(empty, color))
	}
	bottom := "+" + strings.Repeat(border, innerW) + "+"
	lines = append(lines, colorize(bottom, color))
	return strings.Join(lines, "\n")
}

func renderTerminalBlock(history []string, input string, width, height int) string {
	innerW := max(1, width-2)
	border := "+"
	top := border + strings.Repeat("=", innerW) + border
	var lines []string
	lines = append(lines, colorize(top, Blue))

	// how many lines for history: height - 3 (header + input + bottom)
	histLines := height - 3
	if histLines < 0 {
		histLines = 0
	}
	// take last histLines from history
	start := 0
	if len(history) > histLines {
		start = len(history) - histLines
	}
	for i := start; i < len(history); i++ {
		line := history[i]
		if len(stripANSI(line)) > innerW {
			line = truncateDisplay(line, innerW)
		}
		lines = append(lines, colorize("|"+padRight(line, innerW)+"|", Blue))
	}
	// fill if not enough
	for len(lines) < histLines+1 {
		lines = append(lines, colorize("|"+padRight("", innerW)+"|", Blue))
	}
	// input line
	in := "> " + input
	if len(in) > innerW {
		in = in[len(in)-innerW:] // show tail
	}
	lines = append(lines, colorize("|"+padRight(in, innerW)+"|", Blue))

	// bottom
	lines = append(lines, colorize(top, Blue))
	return strings.Join(lines, "\n")
}

func (m model) View() string {
	if m.width == 0 || m.height == 0 {
		return "Загрузка..."
	}
	// compute heights
	termH := max(6, m.height/4)          // bottom terminal height
	panelAreaH := m.height - termH - 2   // top area for panels (+ spacing)
	panelW := max(20, (m.width-6)/2)     // width per panel
	// build left/right blocks
	leftBlock := renderPanelBlock(m.leftDir, m.leftFiles, m.cursorLeft, m.offsetLeft, panelW, panelAreaH, m.activeLeft && m.focus == "panels")
	rightBlock := renderPanelBlock(m.rightDir, m.rightFiles, m.cursorRight, m.offsetRight, panelW, panelAreaH, !m.activeLeft && m.focus == "panels")

	// join horizontally
	leftLines := strings.Split(leftBlock, "\n")
	rightLines := strings.Split(rightBlock, "\n")
	maxLines := max(len(leftLines), len(rightLines))
	var topLines []string
	for i := 0; i < maxLines; i++ {
		l := ""
		if i < len(leftLines) {
			l = leftLines[i]
		} else {
			l = strings.Repeat(" ", panelW)
		}
		r := ""
		if i < len(rightLines) {
			r = rightLines[i]
		} else {
			r = strings.Repeat(" ", panelW)
		}
		topLines = append(topLines, l+"  "+r)
	}
	topUI := strings.Join(topLines, "\n")

	// terminal block full width
	termBlock := renderTerminalBlock(m.termHistory, m.termInput, m.width-4, termH)

	// combine with a separation line
	out := topUI + "\n\n" + termBlock
	return out
}

// helpers

func padRight(s string, w int) string {
	ln := len(stripANSI(s))
	if ln >= w {
		return s
	}
	return s + strings.Repeat(" ", w-ln)
}

func truncateDisplay(s string, w int) string {
	// naive truncate that keeps ansi sequences (we assume minimal here)
	if len(stripANSI(s)) <= w {
		return s
	}
	// strip ANSI for measuring, but return a cut on raw string may break ansi — keep simple: shorten visible part
	plain := stripANSI(s)
	if len(plain) <= w {
		return s
	}
	plain = plain[:w-1] + "…"
	return plain
}

func colorize(s, color string) string {
	if color == "" {
		return s
	}
	return color + s + Reset
}

func stripANSI(s string) string {
	// remove our used color sequences
	out := s
	out = strings.ReplaceAll(out, Reset, "")
	out = strings.ReplaceAll(out, Green, "")
	out = strings.ReplaceAll(out, Gray, "")
	out = strings.ReplaceAll(out, Yellow, "")
	out = strings.ReplaceAll(out, Blue, "")
	return out
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
